
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">eve-profit2/internal/api/handlers/character.go (0.0%)</option>
				
				<option value="file1">eve-profit2/internal/api/handlers/health.go (100.0%)</option>
				
				<option value="file2">eve-profit2/internal/api/handlers/items.go (0.0%)</option>
				
				<option value="file3">eve-profit2/internal/api/handlers/market.go (0.0%)</option>
				
				<option value="file4">eve-profit2/internal/api/handlers/profit.go (0.0%)</option>
				
				<option value="file5">eve-profit2/internal/cache/cache.go (52.7%)</option>
				
				<option value="file6">eve-profit2/internal/config/config.go (78.9%)</option>
				
				<option value="file7">eve-profit2/internal/repository/sde.go (49.2%)</option>
				
				<option value="file8">eve-profit2/internal/service/services.go (17.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// Error message constants following DRY principle
const (
        ErrInvalidCharacterID = "Invalid character ID"
        ErrCharacterInfo      = "Failed to get character info"
        ErrCharacterAssets    = "Failed to get character assets"
        ErrCharacterWallet    = "Failed to get character wallet"
        ErrCharacterOrders    = "Failed to get character orders"
        ErrCharacterSkills    = "Failed to get character skills"
)

// CharacterService defines the interface for character operations
type CharacterService interface {
        GetCharacterInfo(characterID int32) (interface{}, error)
        GetCharacterAssets(characterID int32) (interface{}, error)
        GetCharacterWallet(characterID int32) (interface{}, error)
        GetCharacterOrders(characterID int32) (interface{}, error)
        GetCharacterSkills(characterID int32) (interface{}, error)
}

type CharacterHandler struct {
        characterService CharacterService
}

func NewCharacterHandler(characterService interface{}) *CharacterHandler <span class="cov0" title="0">{
        if service, ok := characterService.(CharacterService); ok </span><span class="cov0" title="0">{
                return &amp;CharacterHandler{characterService: service}
        }</span>
        // Return with nil service for now - Phase 4 implementation will add actual service
        <span class="cov0" title="0">return &amp;CharacterHandler{}</span>
}

// GetCharacterInfo retrieves character information by ID
func (h *CharacterHandler) GetCharacterInfo(c *gin.Context) <span class="cov0" title="0">{
        characterID, err := h.extractCharacterIDFromPath(c)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, ErrInvalidCharacterID, err)
                return
        }</span>

        <span class="cov0" title="0">if h.characterService == nil </span><span class="cov0" title="0">{
                h.respondWithNotImplemented(c, "Character info endpoint")
                return
        }</span>

        <span class="cov0" title="0">data, err := h.characterService.GetCharacterInfo(characterID)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusInternalServerError, ErrCharacterInfo, err)
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, data)</span>
}

// GetAssets retrieves character assets
func (h *CharacterHandler) GetAssets(c *gin.Context) <span class="cov0" title="0">{
        characterID, err := h.extractCharacterIDFromPath(c)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, ErrInvalidCharacterID, err)
                return
        }</span>

        <span class="cov0" title="0">if h.characterService == nil </span><span class="cov0" title="0">{
                h.respondWithNotImplemented(c, "Character assets endpoint")
                return
        }</span>

        <span class="cov0" title="0">data, err := h.characterService.GetCharacterAssets(characterID)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusInternalServerError, ErrCharacterAssets, err)
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, data)</span>
}

// GetWallet retrieves character wallet information
func (h *CharacterHandler) GetWallet(c *gin.Context) <span class="cov0" title="0">{
        characterID, err := h.extractCharacterIDFromPath(c)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, ErrInvalidCharacterID, err)
                return
        }</span>

        <span class="cov0" title="0">if h.characterService == nil </span><span class="cov0" title="0">{
                h.respondWithNotImplemented(c, "Character wallet endpoint")
                return
        }</span>

        <span class="cov0" title="0">data, err := h.characterService.GetCharacterWallet(characterID)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusInternalServerError, ErrCharacterWallet, err)
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, data)</span>
}

// GetOrders retrieves character market orders
func (h *CharacterHandler) GetOrders(c *gin.Context) <span class="cov0" title="0">{
        characterID, err := h.extractCharacterIDFromPath(c)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, ErrInvalidCharacterID, err)
                return
        }</span>

        <span class="cov0" title="0">if h.characterService == nil </span><span class="cov0" title="0">{
                h.respondWithNotImplemented(c, "Character orders endpoint")
                return
        }</span>

        <span class="cov0" title="0">data, err := h.characterService.GetCharacterOrders(characterID)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusInternalServerError, ErrCharacterOrders, err)
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, data)</span>
}

// GetSkills retrieves character skills
func (h *CharacterHandler) GetSkills(c *gin.Context) <span class="cov0" title="0">{
        characterID, err := h.extractCharacterIDFromPath(c)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusBadRequest, ErrInvalidCharacterID, err)
                return
        }</span>

        <span class="cov0" title="0">if h.characterService == nil </span><span class="cov0" title="0">{
                h.respondWithNotImplemented(c, "Character skills endpoint")
                return
        }</span>

        <span class="cov0" title="0">data, err := h.characterService.GetCharacterSkills(characterID)
        if err != nil </span><span class="cov0" title="0">{
                h.respondWithError(c, http.StatusInternalServerError, ErrCharacterSkills, err)
                return
        }</span>

        <span class="cov0" title="0">h.respondWithSuccess(c, data)</span>
}

// InitiateLogin starts the EVE SSO login flow
func (h *CharacterHandler) InitiateLogin(c *gin.Context) <span class="cov0" title="0">{
        h.respondWithNotImplemented(c, "EVE SSO login endpoint")
}</span>

// Helper methods following DRY principle

// extractCharacterIDFromPath extracts and validates character ID from URL path
func (h *CharacterHandler) extractCharacterIDFromPath(c *gin.Context) (int32, error) <span class="cov0" title="0">{
        characterIDStr := c.Param("characterID")
        if characterIDStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("character ID is required")
        }</span>

        <span class="cov0" title="0">characterID, err := strconv.ParseInt(characterIDStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid character ID format: %w", err)
        }</span>

        <span class="cov0" title="0">if characterID &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("character ID must be positive")
        }</span>

        <span class="cov0" title="0">return int32(characterID), nil</span>
}

// respondWithError sends a standardized error response
func (h *CharacterHandler) respondWithError(c *gin.Context, statusCode int, message string, err error) <span class="cov0" title="0">{
        c.JSON(statusCode, gin.H{
                "error":   message,
                "details": err.Error(),
        })
}</span>

// respondWithSuccess sends a standardized success response
func (h *CharacterHandler) respondWithSuccess(c *gin.Context, data interface{}) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    data,
        })
}</span>

// respondWithNotImplemented sends a standardized not implemented response
func (h *CharacterHandler) respondWithNotImplemented(c *gin.Context, endpoint string) <span class="cov0" title="0">{
        c.JSON(http.StatusNotImplemented, gin.H{
                "message": endpoint + " - not implemented yet (Phase 4)",
                "phase":   "Phase 4 - API Handlers Implementation",
        })
}</span>

func (h *CharacterHandler) HandleCallback(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "EVE SSO callback endpoint - not implemented yet",
        })
}</span>

func (h *CharacterHandler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Token refresh endpoint - not implemented yet",
        })
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

type HealthHandler struct{}

func NewHealthHandler() *HealthHandler <span class="cov8" title="1">{
        return &amp;HealthHandler{}
}</span>

type HealthResponse struct {
        Status    string    `json:"status"`
        Timestamp time.Time `json:"timestamp"`
        Version   string    `json:"version"`
        Service   string    `json:"service"`
}

func (h *HealthHandler) HealthCheck(c *gin.Context) <span class="cov8" title="1">{
        response := HealthResponse{
                Status:    "healthy",
                Timestamp: time.Now(),
                Version:   "1.0.0",
                Service:   "eve-profit2-backend",
        }

        c.JSON(http.StatusOK, response)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type ItemHandler struct {
        // itemService *service.ItemService
}

func NewItemHandler(itemService interface{}) *ItemHandler <span class="cov0" title="0">{
        return &amp;ItemHandler{}
}</span>

func (h *ItemHandler) SearchItems(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Item search endpoint - not implemented yet",
                "query":   c.Query("q"),
        })
}</span>

func (h *ItemHandler) GetItemDetails(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Item details endpoint - not implemented yet",
                "item_id": c.Param("item_id"),
        })
}</span>

func (h *ItemHandler) GetCategories(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Categories endpoint - not implemented yet",
        })
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type MarketHandler struct {
        // marketService *service.MarketService
}

func NewMarketHandler(marketService interface{}) *MarketHandler <span class="cov0" title="0">{
        return &amp;MarketHandler{}
}</span>

func (h *MarketHandler) GetItemPrices(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Market prices endpoint - not implemented yet",
                "item_id": c.Param("item_id"),
        })
}</span>

func (h *MarketHandler) GetItemOrders(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Market orders endpoint - not implemented yet",
                "item_id": c.Param("item_id"),
        })
}</span>

func (h *MarketHandler) GetPriceHistory(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Price history endpoint - not implemented yet",
                "item_id": c.Param("item_id"),
        })
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type ProfitHandler struct {
        // profitService *service.ProfitService
}

func NewProfitHandler(profitService interface{}) *ProfitHandler <span class="cov0" title="0">{
        return &amp;ProfitHandler{}
}</span>

func (h *ProfitHandler) CalculateProfit(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Profit calculation endpoint - not implemented yet",
        })
}</span>

func (h *ProfitHandler) GetTradingRoutes(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Trading routes endpoint - not implemented yet",
        })
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/allegro/bigcache/v3"
)

type CacheManager struct {
        marketCache    *bigcache.BigCache
        characterCache *bigcache.BigCache
        sdeCache       *bigcache.BigCache
}

type CacheConfig struct {
        Shards             int
        LifeWindow         time.Duration
        CleanWindow        time.Duration
        MaxEntriesInWindow int
        MaxEntrySize       int
        HardMaxCacheSize   int
}

// NewCacheManager creates a new cache manager with optimized configurations
func NewCacheManager() (*CacheManager, error) <span class="cov8" title="1">{
        // Market data cache - short TTL for live data
        marketConfig := bigcache.Config{
                Shards:             1024,
                LifeWindow:         5 * time.Minute,
                CleanWindow:        1 * time.Minute,
                MaxEntriesInWindow: 1000 * 10 * 60,
                MaxEntrySize:       500,
                HardMaxCacheSize:   256, // 256MB
        }

        marketCache, err := bigcache.New(context.Background(), marketConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create market cache: %w", err)
        }</span>

        // Character data cache - medium TTL
        <span class="cov8" title="1">characterConfig := bigcache.Config{
                Shards:             256,
                LifeWindow:         15 * time.Minute,
                CleanWindow:        2 * time.Minute,
                MaxEntriesInWindow: 1000 * 10 * 60,
                MaxEntrySize:       2000,
                HardMaxCacheSize:   128, // 128MB
        }

        characterCache, err := bigcache.New(context.Background(), characterConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create character cache: %w", err)
        }</span>

        // SDE data cache - long TTL for static data
        <span class="cov8" title="1">sdeConfig := bigcache.Config{
                Shards:             512,
                LifeWindow:         24 * time.Hour,
                CleanWindow:        10 * time.Minute,
                MaxEntriesInWindow: 1000 * 10 * 60,
                MaxEntrySize:       1000,
                HardMaxCacheSize:   512, // 512MB
        }

        sdeCache, err := bigcache.New(context.Background(), sdeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SDE cache: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;CacheManager{
                marketCache:    marketCache,
                characterCache: characterCache,
                sdeCache:       sdeCache,
        }, nil</span>
}

// Market Cache Methods
func (c *CacheManager) SetMarketData(key string, data interface{}, ttl time.Duration) error <span class="cov8" title="1">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.marketCache.Set(key, jsonData)</span>
}

func (c *CacheManager) GetMarketData(key string, dest interface{}) error <span class="cov8" title="1">{
        data, err := c.marketCache.Get(key)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(data, dest)</span>
}

// Character Cache Methods
func (c *CacheManager) SetCharacterData(key string, data interface{}) error <span class="cov8" title="1">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.characterCache.Set(key, jsonData)</span>
}

func (c *CacheManager) GetCharacterData(key string, dest interface{}) error <span class="cov8" title="1">{
        data, err := c.characterCache.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(data, dest)</span>
}

// SDE Cache Methods
func (c *CacheManager) SetSDEData(key string, data interface{}) error <span class="cov8" title="1">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.sdeCache.Set(key, jsonData)</span>
}

func (c *CacheManager) GetSDEData(key string, dest interface{}) error <span class="cov8" title="1">{
        data, err := c.sdeCache.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(data, dest)</span>
}

// Utility Methods
func (c *CacheManager) DeleteMarketData(key string) error <span class="cov0" title="0">{
        return c.marketCache.Delete(key)
}</span>

func (c *CacheManager) DeleteCharacterData(key string) error <span class="cov0" title="0">{
        return c.characterCache.Delete(key)
}</span>

func (c *CacheManager) DeleteSDEData(key string) error <span class="cov0" title="0">{
        return c.sdeCache.Delete(key)
}</span>

// Cache Statistics
type CacheStats struct {
        MarketStats    bigcache.Stats `json:"market_stats"`
        CharacterStats bigcache.Stats `json:"character_stats"`
        SDEStats       bigcache.Stats `json:"sde_stats"`
}

func (c *CacheManager) GetStats() CacheStats <span class="cov0" title="0">{
        return CacheStats{
                MarketStats:    c.marketCache.Stats(),
                CharacterStats: c.characterCache.Stats(),
                SDEStats:       c.sdeCache.Stats(),
        }
}</span>

// Reset all caches
func (c *CacheManager) Reset() error <span class="cov0" title="0">{
        if err := c.marketCache.Reset(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := c.characterCache.Reset(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := c.sdeCache.Reset(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Close all caches
func (c *CacheManager) Close() error <span class="cov0" title="0">{
        if err := c.marketCache.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := c.characterCache.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := c.sdeCache.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// Config holds all application configuration
type Config struct {
        // Server Configuration
        ServerPort string
        APIBaseURL string
        CORSOrigin string
        DebugMode  bool
        LogLevel   string

        // EVE ESI Configuration
        ESIClientID     string
        ESIClientSecret string
        ESICallbackURL  string
        ESIBaseURL      string
        ESIScopes       []string

        // EVE SSO Configuration
        EVESSOBaseURL      string
        EVESSOAuthorizeURL string
        EVESSOTokenURL     string
        EVESSOVerifyURL    string

        // Rate Limiting
        ESIRateLimit   int
        ESIBurstLimit  int
        ESITimeoutSecs int

        // Caching Configuration
        CacheTTLMarketOrders  time.Duration
        CacheTTLMarketHistory time.Duration
        CacheTTLTypeInfo      time.Duration
        CacheTTLCharacterInfo time.Duration

        // Database Configuration
        SDEDatabasePath string
}

// Load reads configuration from environment variables with sensible defaults
func Load() *Config <span class="cov8" title="1">{
        return &amp;Config{
                // Server Configuration
                ServerPort: getEnv("SERVER_PORT", "9000"),
                APIBaseURL: getEnv("API_BASE_URL", "http://localhost:9000"),
                CORSOrigin: getEnv("CORS_ORIGIN", "http://localhost:3000"),
                DebugMode:  getEnvBool("DEBUG_MODE", true),
                LogLevel:   getEnv("LOG_LEVEL", "info"),

                // EVE ESI Configuration
                ESIClientID:     getEnv("ESI_CLIENT_ID", "0928b4bcd20242aeb9b8be10f5451094"),
                ESIClientSecret: getEnv("ESI_CLIENT_SECRET", "AQPjLZ3VYAewR59J5jStZs52dY7jISGVLwXv5NA"),
                ESICallbackURL:  getEnv("ESI_CALLBACK_URL", "http://localhost:9000/callback"),
                ESIBaseURL:      getEnv("ESI_BASE_URL", "https://esi.evetech.net"),
                ESIScopes: getEnvSlice("ESI_SCOPES", []string{
                        "publicData",
                        "esi-location.read_location.v1",
                        "esi-location.read_ship_type.v1",
                        "esi-skills.read_skills.v1",
                        "esi-wallet.read_character_wallet.v1",
                        "esi-universe.read_structures.v1",
                        "esi-assets.read_assets.v1",
                        "esi-fittings.read_fittings.v1",
                        "esi-characters.read_standings.v1",
                }),

                // EVE SSO Configuration
                EVESSOBaseURL:      getEnv("EVE_SSO_BASE_URL", "https://login.eveonline.com"),
                EVESSOAuthorizeURL: getEnv("EVE_SSO_AUTHORIZE_URL", "https://login.eveonline.com/v2/oauth/authorize"),
                EVESSOTokenURL:     getEnv("EVE_SSO_TOKEN_URL", "https://login.eveonline.com/v2/oauth/token"),
                EVESSOVerifyURL:    getEnv("EVE_SSO_VERIFY_URL", "https://login.eveonline.com/oauth/verify"),

                // Rate Limiting
                ESIRateLimit:   getEnvInt("ESI_RATE_LIMIT", 150),
                ESIBurstLimit:  getEnvInt("ESI_BURST_LIMIT", 400),
                ESITimeoutSecs: getEnvInt("ESI_TIMEOUT_SECONDS", 30),

                // Caching Configuration
                CacheTTLMarketOrders:  time.Duration(getEnvInt("CACHE_TTL_MARKET_ORDERS", 300)) * time.Second,
                CacheTTLMarketHistory: time.Duration(getEnvInt("CACHE_TTL_MARKET_HISTORY", 3600)) * time.Second,
                CacheTTLTypeInfo:      time.Duration(getEnvInt("CACHE_TTL_TYPE_INFO", 86400)) * time.Second,
                CacheTTLCharacterInfo: time.Duration(getEnvInt("CACHE_TTL_CHARACTER_INFO", 1800)) * time.Second,

                // Database Configuration
                SDEDatabasePath: getEnv("SDE_DATABASE_PATH", "./data/sqlite-latest.sqlite"),
        }
}</span>

// Helper functions for reading environment variables
func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        return intVal
                }</span>
                // Log warning for invalid values but continue with default
                <span class="cov8" title="1">fmt.Printf("Warning: Invalid integer value for %s: %s, using default: %d\n", key, value, defaultValue)</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if boolVal, err := strconv.ParseBool(value); err == nil </span><span class="cov8" title="1">{
                        return boolVal
                }</span>
                // Log warning for invalid values but continue with default
                <span class="cov0" title="0">fmt.Printf("Warning: Invalid boolean value for %s: %s, using default: %t\n", key, value, defaultValue)</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func getEnvSlice(key string, defaultValue []string) []string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return strings.Fields(value) // Split by whitespace
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetServerAddress returns the full server address
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return ":" + c.ServerPort
}</span>

// GetESIScopesString returns ESI scopes as space-separated string
func (c *Config) GetESIScopesString() string <span class="cov0" title="0">{
        return strings.Join(c.ESIScopes, " ")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        _ "github.com/mattn/go-sqlite3"
)

// SDEItem represents an item from SDE
type SDEItem struct {
        TypeID      int32   `json:"typeId"`
        TypeName    string  `json:"typeName"`
        GroupID     int32   `json:"groupId"`
        Volume      float64 `json:"volume"`
        MarketGroup int32   `json:"marketGroupID,omitempty"`
        Published   bool    `json:"published"`
}

// SDEStation represents a station from SDE
type SDEStation struct {
        StationID   int64  `json:"stationId"`
        StationName string `json:"stationName"`
        SystemID    int32  `json:"systemId"`
        RegionID    int32  `json:"regionId"`
        TypeID      int32  `json:"typeId"`
}

// SDERegion represents a region from SDE
type SDERegion struct {
        RegionID   int32  `json:"regionId"`
        RegionName string `json:"regionName"`
}

// SDERepository handles SDE SQLite database operations
type SDERepository struct {
        db *sql.DB
}

func NewSDERepository(dbPath string) (*SDERepository, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Test connection
        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;SDERepository{db: db}, nil</span>
}

func (r *SDERepository) Close() error <span class="cov8" title="1">{
        if r.db != nil </span><span class="cov8" title="1">{
                return r.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *SDERepository) Ping() error <span class="cov8" title="1">{
        if r.db == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection is nil")
        }</span>
        <span class="cov8" title="1">return r.db.Ping()</span>
}

// GetItemByID retrieves a single item by TypeID
func (r *SDERepository) GetItemByID(typeID int32) (*SDEItem, error) <span class="cov8" title="1">{
        query := `
                SELECT typeID, typeName, groupID, volume, marketGroupID, published
                FROM invTypes 
                WHERE typeID = ?
        `

        var item SDEItem
        var marketGroup sql.NullInt32

        err := r.db.QueryRow(query, typeID).Scan(
                &amp;item.TypeID,
                &amp;item.TypeName,
                &amp;item.GroupID,
                &amp;item.Volume,
                &amp;marketGroup,
                &amp;item.Published,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("item not found: typeID %d", typeID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get item: %w", err)
        }</span>

        <span class="cov8" title="1">if marketGroup.Valid </span><span class="cov8" title="1">{
                item.MarketGroup = marketGroup.Int32
        }</span>

        <span class="cov8" title="1">return &amp;item, nil</span>
}

// SearchItems searches for items by name
func (r *SDERepository) SearchItems(searchTerm string, limit int) ([]*SDEItem, error) <span class="cov8" title="1">{
        query := `
                SELECT typeID, typeName, groupID, volume, marketGroupID, published
                FROM invTypes 
                WHERE typeName LIKE ? AND published = 1
                ORDER BY typeName
                LIMIT ?
        `

        rows, err := r.db.Query(query, "%"+searchTerm+"%", limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search items: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var items []*SDEItem
        for rows.Next() </span><span class="cov8" title="1">{
                var item SDEItem
                var marketGroup sql.NullInt32

                err := rows.Scan(
                        &amp;item.TypeID,
                        &amp;item.TypeName,
                        &amp;item.GroupID,
                        &amp;item.Volume,
                        &amp;marketGroup,
                        &amp;item.Published,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan item: %w", err)
                }</span>

                <span class="cov8" title="1">if marketGroup.Valid </span><span class="cov8" title="1">{
                        item.MarketGroup = marketGroup.Int32
                }</span>

                <span class="cov8" title="1">items = append(items, &amp;item)</span>
        }

        <span class="cov8" title="1">return items, nil</span>
}

// GetStationsBySystem retrieves all stations in a system
func (r *SDERepository) GetStationsBySystem(systemID int32) ([]*SDEStation, error) <span class="cov0" title="0">{
        query := `
                SELECT stationID, stationName, solarSystemID, regionID, stationTypeID
                FROM staStations 
                WHERE solarSystemID = ?
        `

        rows, err := r.db.Query(query, systemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var stations []*SDEStation
        for rows.Next() </span><span class="cov0" title="0">{
                var station SDEStation

                err := rows.Scan(
                        &amp;station.StationID,
                        &amp;station.StationName,
                        &amp;station.SystemID,
                        &amp;station.RegionID,
                        &amp;station.TypeID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan station: %w", err)
                }</span>

                <span class="cov0" title="0">stations = append(stations, &amp;station)</span>
        }

        <span class="cov0" title="0">return stations, nil</span>
}

// GetRegions retrieves all regions with limit
func (r *SDERepository) GetRegions(limit int) ([]*SDERegion, error) <span class="cov0" title="0">{
        query := `
                SELECT regionID, regionName
                FROM mapRegions
                ORDER BY regionName
                LIMIT ?
        `

        rows, err := r.db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get regions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var regions []*SDERegion
        for rows.Next() </span><span class="cov0" title="0">{
                var region SDERegion

                err := rows.Scan(
                        &amp;region.RegionID,
                        &amp;region.RegionName,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan region: %w", err)
                }</span>

                <span class="cov0" title="0">regions = append(regions, &amp;region)</span>
        }

        <span class="cov0" title="0">return regions, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package service

import (
        "context"
        "fmt"
        "sync"
        "time"

        "eve-profit2/internal/models"
        "eve-profit2/internal/repository"
)

// MarketService handles market data operations with ESI integration
type MarketService struct {
        esiClient ESIClient
        cache     map[string]interface{}
        cacheMux  sync.RWMutex
        cacheTTL  time.Duration
}

func NewMarketService(esiClient ESIClient) *MarketService <span class="cov8" title="1">{
        return &amp;MarketService{
                esiClient: esiClient,
                cache:     make(map[string]interface{}),
                cacheTTL:  5 * time.Minute, // 5-minute cache TTL
        }
}</span>

// getCacheKey generates a cache key for market data
func (s *MarketService) getCacheKey(regionID int32, typeIDs []int32) string <span class="cov0" title="0">{
        return fmt.Sprintf("market_%d_%v", regionID, typeIDs)
}</span>

// getCachedData retrieves data from cache if available and not expired
func (s *MarketService) getCachedData(key string) (*MarketDataResponse, bool) <span class="cov0" title="0">{
        s.cacheMux.RLock()
        defer s.cacheMux.RUnlock()

        if data, exists := s.cache[key]; exists </span><span class="cov0" title="0">{
                if response, ok := data.(*MarketDataResponse); ok </span><span class="cov0" title="0">{
                        if time.Since(response.UpdatedAt) &lt; s.cacheTTL </span><span class="cov0" title="0">{
                                return response, true
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, false</span>
}

// setCachedData stores data in cache
func (s *MarketService) setCachedData(key string, data *MarketDataResponse) <span class="cov0" title="0">{
        s.cacheMux.Lock()
        defer s.cacheMux.Unlock()
        s.cache[key] = data
}</span>

// MarketDataRequest represents a request for market data
type MarketDataRequest struct {
        RegionID int32   `json:"region_id"`
        TypeIDs  []int32 `json:"type_ids"`
}

// MarketDataResponse represents aggregated market data
type MarketDataResponse struct {
        RegionID  int32                            `json:"region_id"`
        Data      map[int32]*models.ItemPrice      `json:"data"`
        Orders    map[int32][]models.MarketOrder   `json:"orders,omitempty"`
        History   map[int32][]models.MarketHistory `json:"history,omitempty"`
        UpdatedAt time.Time                        `json:"updated_at"`
}

// GetMarketData retrieves comprehensive market data for specified types in a region
func (s *MarketService) GetMarketData(ctx context.Context, req MarketDataRequest) (*MarketDataResponse, error) <span class="cov0" title="0">{
        if err := s.validateMarketDataRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check cache first
        <span class="cov0" title="0">cacheKey := s.getCacheKey(req.RegionID, req.TypeIDs)
        if cachedData, found := s.getCachedData(cacheKey); found </span><span class="cov0" title="0">{
                return cachedData, nil
        }</span>

        <span class="cov0" title="0">results, err := s.fetchMarketDataConcurrently(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">response := s.aggregateMarketDataResponse(req.RegionID, results)
        s.setCachedData(cacheKey, response)

        return response, nil</span>
}

// validateMarketDataRequest validates the market data request
func (s *MarketService) validateMarketDataRequest(req MarketDataRequest) error <span class="cov0" title="0">{
        if len(req.TypeIDs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no type IDs provided")
        }</span>
        <span class="cov0" title="0">if req.RegionID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid region ID: %d", req.RegionID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// marketDataResult represents the result of fetching data for a single type
type marketDataResult struct {
        typeID  int32
        orders  []models.MarketOrder
        history []models.MarketHistory
        err     error
}

// fetchMarketDataConcurrently fetches market data for all type IDs concurrently
func (s *MarketService) fetchMarketDataConcurrently(ctx context.Context, req MarketDataRequest) ([]marketDataResult, error) <span class="cov0" title="0">{
        results := make(chan marketDataResult, len(req.TypeIDs))
        var wg sync.WaitGroup

        for _, typeID := range req.TypeIDs </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(tid int32) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        s.fetchSingleTypeMarketData(ctx, req.RegionID, tid, results)
                }</span>(typeID)
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(results)
        }</span>()

        <span class="cov0" title="0">return s.collectMarketDataResults(results)</span>
}

// fetchSingleTypeMarketData fetches market data for a single type ID
func (s *MarketService) fetchSingleTypeMarketData(ctx context.Context, regionID, typeID int32, results chan&lt;- marketDataResult) <span class="cov0" title="0">{
        orders, err := s.esiClient.GetMarketOrders(ctx, regionID, typeID)
        if err != nil </span><span class="cov0" title="0">{
                results &lt;- marketDataResult{
                        typeID: typeID,
                        err:    fmt.Errorf("failed to get orders for type %d: %w", typeID, err),
                }
                return
        }</span>

        <span class="cov0" title="0">history, err := s.esiClient.GetMarketHistory(ctx, regionID, typeID)
        if err != nil </span><span class="cov0" title="0">{
                results &lt;- marketDataResult{
                        typeID: typeID,
                        err:    fmt.Errorf("failed to get history for type %d: %w", typeID, err),
                }
                return
        }</span>

        <span class="cov0" title="0">results &lt;- marketDataResult{
                typeID:  typeID,
                orders:  orders,
                history: history,
        }</span>
}

// collectMarketDataResults collects and validates all market data results
func (s *MarketService) collectMarketDataResults(results &lt;-chan marketDataResult) ([]marketDataResult, error) <span class="cov0" title="0">{
        var collectedResults []marketDataResult

        for res := range results </span><span class="cov0" title="0">{
                if res.err != nil </span><span class="cov0" title="0">{
                        return nil, res.err
                }</span>
                <span class="cov0" title="0">collectedResults = append(collectedResults, res)</span>
        }

        <span class="cov0" title="0">return collectedResults, nil</span>
}

// aggregateMarketDataResponse aggregates results into the final response
func (s *MarketService) aggregateMarketDataResponse(regionID int32, results []marketDataResult) *MarketDataResponse <span class="cov0" title="0">{
        response := &amp;MarketDataResponse{
                RegionID:  regionID,
                Data:      make(map[int32]*models.ItemPrice),
                Orders:    make(map[int32][]models.MarketOrder),
                History:   make(map[int32][]models.MarketHistory),
                UpdatedAt: time.Now(),
        }

        for _, res := range results </span><span class="cov0" title="0">{
                response.Orders[res.typeID] = res.orders
                response.History[res.typeID] = res.history

                // Calculate current market prices from orders
                itemPrice := s.calculateItemPrice(res.orders, res.history)
                itemPrice.TypeID = res.typeID
                itemPrice.LastUpdated = response.UpdatedAt
                response.Data[res.typeID] = itemPrice
        }</span>

        <span class="cov0" title="0">return response</span>
}

// calculateItemPrice aggregates market orders into current price information
func (s *MarketService) calculateItemPrice(orders []models.MarketOrder, _ []models.MarketHistory) *models.ItemPrice <span class="cov0" title="0">{
        price := &amp;models.ItemPrice{
                BuyMax:     0,
                SellMin:    0,
                BuyVolume:  0,
                SellVolume: 0,
        }

        if len(orders) == 0 </span><span class="cov0" title="0">{
                return price
        }</span>

        // Separate buy and sell orders
        <span class="cov0" title="0">var buyOrders, sellOrders []models.MarketOrder
        for _, order := range orders </span><span class="cov0" title="0">{
                if order.IsBuyOrder </span><span class="cov0" title="0">{
                        buyOrders = append(buyOrders, order)
                }</span> else<span class="cov0" title="0"> {
                        sellOrders = append(sellOrders, order)
                }</span>
        }

        // Calculate best buy price (highest buy order)
        <span class="cov0" title="0">for _, order := range buyOrders </span><span class="cov0" title="0">{
                if order.Price &gt; price.BuyMax </span><span class="cov0" title="0">{
                        price.BuyMax = order.Price
                }</span>
                <span class="cov0" title="0">price.BuyVolume += int64(order.VolumeRemain)</span>
        }

        // Calculate best sell price (lowest sell order)
        <span class="cov0" title="0">for i, order := range sellOrders </span><span class="cov0" title="0">{
                if i == 0 || order.Price &lt; price.SellMin </span><span class="cov0" title="0">{
                        price.SellMin = order.Price
                }</span>
                <span class="cov0" title="0">price.SellVolume += int64(order.VolumeRemain)</span>
        }

        <span class="cov0" title="0">return price</span>
}

// ItemService handles SDE item operations
type ItemService struct {
        sdeRepo      *repository.SDERepository
        cacheManager interface{}
}

func NewItemService(sdeRepo interface{}, cacheManager interface{}) *ItemService <span class="cov8" title="1">{
        repo, ok := sdeRepo.(*repository.SDERepository)
        if !ok </span><span class="cov0" title="0">{
                return &amp;ItemService{}
        }</span>
        <span class="cov8" title="1">return &amp;ItemService{
                sdeRepo:      repo,
                cacheManager: cacheManager,
        }</span>
}

// GetItemByID retrieves an item by its type ID
func (s *ItemService) GetItemByID(typeID int32) (*models.Item, error) <span class="cov8" title="1">{
        if s.sdeRepo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SDE repository not available")
        }</span>

        <span class="cov8" title="1">sdeItem, err := s.sdeRepo.GetItemByID(typeID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Convert SDE item to models.Item
        <span class="cov8" title="1">item := &amp;models.Item{
                TypeID:   sdeItem.TypeID,
                TypeName: sdeItem.TypeName,
                GroupID:  sdeItem.GroupID,
                Volume:   sdeItem.Volume,
                Mass:     0, // Mass not available in SDE
        }

        return item, nil</span>
}

// SearchItems searches for items by name pattern
func (s *ItemService) SearchItems(pattern string, limit int) ([]models.Item, error) <span class="cov8" title="1">{
        if s.sdeRepo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SDE repository not available")
        }</span>

        <span class="cov8" title="1">sdeItems, err := s.sdeRepo.SearchItems(pattern, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert SDE items to models.Item
        <span class="cov8" title="1">var items []models.Item
        for _, sdeItem := range sdeItems </span><span class="cov8" title="1">{
                item := models.Item{
                        TypeID:   sdeItem.TypeID,
                        TypeName: sdeItem.TypeName,
                        GroupID:  sdeItem.GroupID,
                        Volume:   sdeItem.Volume,
                        Mass:     0, // Mass not available in SDE
                }
                items = append(items, item)
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
